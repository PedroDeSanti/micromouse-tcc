---
interface Props {
  modelPath: string;
  height?: string;
}

const { modelPath, height = "500px" } = Astro.props;
---

<div id="three-container" style={`width: 100%; height: ${height}; background: #1a1a1a; border-radius: 8px;`} data-model-path={modelPath}>
  <div id="loading-text" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: sans-serif;">Loading 3D Model...</div>
</div>

<script>
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  const container = document.getElementById('three-container');
  const loadingText = document.getElementById('loading-text');

  if (container) {
    const modelPath = container.dataset.modelPath;
    
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x23262d); // Match Starlight dark theme roughly

    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(5, 5, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 1);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 2);
    dirLight.position.set(5, 10, 7.5);
    scene.add(dirLight);

    const loader = new GLTFLoader();
    
    if (modelPath) {
        loader.load(modelPath, (gltf) => {
        const model = gltf.scene;
        
        // Auto-center and scale
        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 3 / maxDim; // Scale to fit in a reasonable view
        model.scale.setScalar(scale);
        
        // Re-center after scaling
        const box2 = new THREE.Box3().setFromObject(model);
        const center2 = box2.getCenter(new THREE.Vector3());
        model.position.sub(center2);

        scene.add(model);
        
        if (loadingText) loadingText.style.display = 'none';
        
        }, (xhr) => {
            // Progress
            if (loadingText) {
                const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                loadingText.innerText = `Loading: ${percent}%`;
            }
        }, (error) => {
            console.error('Error loading model:', error);
            if (loadingText) loadingText.innerText = 'Error loading model';
        });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // Handle resize
    const onWindowResize = () => {
        if (!container) return;
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    };

    window.addEventListener('resize', onWindowResize);
  }
</script>
